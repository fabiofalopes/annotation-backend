# Project End Goal: The Universal Annotation Platform

## Current State: Specialized Annotation Backend

Currently, our application is a functional annotation backend built with FastAPI and Streamlit, primarily focused on chat disentanglement. It provides:

*   **FastAPI Backend:** A robust API for managing users, projects, data containers, data items, and annotations.
*   **Streamlit Admin UI:** A user-friendly interface for administrative tasks, including:
    *   User management (creation, deletion, role assignment).
    *   Project management (creation, deletion, user assignment).
    *   Data container management (creation, deletion, viewing).
    *   CSV data import (with column mapping) specifically tailored for chat data.
    *   Basic annotation viewing (within the container view).
*   **Database:** SQLite database (using SQLAlchemy) to store all application data.  **(Consider PostgreSQL for production)**
*   **Authentication:** Secure user authentication and authorization using JWT.
*   **Automatic API Documentation:** Swagger/OpenAPI documentation generated by FastAPI.
*   **SQLAdmin Interface:** Direct database management via SQLAdmin.

## Limitations of the Current System

The current system, while functional, has several key limitations:

*   **Data Format Specificity:** Primarily designed for CSV-based chat data. Import and processing are tightly coupled to this format.
*   **Static Endpoints:** API endpoints are hardcoded. Adding support for new data types or annotation tasks requires manual code changes and deployments.
*   **Limited Annotation Capabilities:** The UI provides basic annotation viewing but lacks interactive annotation features.
*   **UI Scalability:** The current UI structure may become unwieldy as more features are added.

## Future Vision: Dynamic and Universal

Our long-term vision is to transform the application into a *universal annotation platform* that is:

*   **Data-Agnostic:** Capable of handling various structured data formats (CSV, JSON, potentially Parquet, Excel, and XML).
*   **Dynamic:** Administrators can define and manage API endpoints *without* writing backend code, using a Streamlit-based configuration interface.
*   **Extensible:** Easily adaptable to new annotation tasks and data types.
*   **User-Friendly:** Provides an intuitive interface for both administrators and annotators.
*   **API-Centric:** The FastAPI backend remains the core, enabling programmatic access and integration with other systems.

## Core Feature: Dynamic Endpoint Generation

The cornerstone of our future vision is **dynamic endpoint generation**. This feature will allow administrators to:

1.  **Define Endpoint Metadata:** Specify the following via a Streamlit UI:
    *   Endpoint path (e.g., `/my-new-data`).
    *   HTTP methods (GET, POST, PUT, DELETE).
    *   Request schema (using a user-friendly form-based builder with an option for advanced JSON Schema editing).
    *   Response schema (similar to the request schema).
    *   Authentication/authorization requirements (e.g., admin-only, role-based access).
    *   Optional database model mapping (selecting an *existing* table).
    *   Description and documentation.

2.  **Automatic Endpoint Creation:** The backend will automatically generate the corresponding FastAPI endpoints based on the provided metadata. This includes:
    *   Creating Pydantic models for request and response validation (using `pydantic.create_model` and a structured internal representation of the schema).
    *   Generating endpoint functions with basic CRUD operations (initially using a generic CRUD handler).
    *   Registering the endpoints with the FastAPI application (using `app.add_api_route` and a dedicated registration system with conflict detection).
    *   Updating the OpenAPI/Swagger documentation.

3.  **Persistence:** Endpoint configurations will be stored in the database (using a dedicated table for endpoint metadata), ensuring they persist across application restarts.

4.  **Beta Feature Rollout:** Dynamic endpoint generation will be introduced as a "beta" feature, coexisting with the existing, specialized functionality. This allows for iterative development, user feedback, and a smooth transition.  Beta features will be clearly marked in the UI.

## Detailed Technical Implementation (New Section)

This section provides a more in-depth look at the technical aspects of dynamic endpoint generation.

### Schema Definition and Management

*   **UI Approach:** A combination of a form-based builder (primary) and a JSON Schema editor (advanced) will be used in the Streamlit UI.  The form-based builder will feature:
    *   Dropdowns for data types (string, integer, float, boolean, datetime).
    *   Text inputs for field names.
    *   Checkboxes/toggles for required/optional status.
    *   Input fields for validation constraints (min/max length, regex patterns).
    *   Expandable sections for nested objects and arrays.
    *   Live preview of the generated Pydantic model.
*   **Internal Representation:** The schema definition will be stored internally as a structured dictionary that maps directly to Pydantic model creation parameters. This facilitates the use of `pydantic.create_model`.
*   **Pydantic Model Generation:**  `pydantic.create_model` will be the primary mechanism for creating dynamic Pydantic models.  UI inputs will be translated into `Field(...)` parameters for validation.
*   **Custom Validators:**  Initially, custom validators will be limited to *predefined options* selectable in the UI (no direct code input) to maintain security.
*   **Versioning:**  A robust versioning system will track all schema changes (timestamp, author), allow multiple versions to coexist, indicate breaking vs. non-breaking changes, and provide options for backward compatibility.  URL path versioning (e.g., `/api/v1/data`, `/api/v2/data`) will be used.

### Endpoint Logic

*   **CRUD Operations:** A generic CRUD handler will be implemented to map the dynamic Pydantic model to appropriate database operations (using SQLAlchemy).
*   **Beyond CRUD:**  The system will support configurable filtering (rule-based system in the UI), sorting (UI controls for fields and direction), pagination (offset-based and cursor-based), and basic aggregation functions (count, sum, average). These will be defined through structured configurations, *not* custom code.
*   **No Custom Code Input:**  To maintain security, administrators will *not* be able to input custom Python code for endpoint logic.

### Database Interaction

*   **Existing Tables Only:**  Initially, dynamic endpoints will only interact with *existing* database tables.  Dynamic table creation is *not* supported in the first phase.
*   **SQLAlchemy ORM:**  SQLAlchemy will be used for all database interactions.
*   **Table Selection:** Administrators will select the target table from a list of available tables in the UI.

### Endpoint Registration

*   **`app.add_api_route`:**  This FastAPI function will be used for endpoint registration.
*   **Dedicated System:**  A dedicated registration system will manage dynamic endpoints, ensuring unique identifiers, grouping endpoints with `APIRouter` instances, and detecting path collisions.
*   **Metadata Tracking:**  Metadata (ownership, usage statistics) will be tracked for each dynamic endpoint.

### Error Handling

*   **Comprehensive Error Handling:**  The system will handle errors at all stages: UI input, schema validation, model creation, endpoint registration, and endpoint execution.
*   **Clear Error Reporting:**  Errors will be reported to administrators through UI notifications, detailed logs, and (optionally) email alerts.

### Data Import

*   **Supported Formats:** CSV and JSON initially, with potential future support for Parquet, Excel, and XML.
*   **Validation:**  Beyond Pydantic validation, the import process will include type checking, range validation, referential integrity checks (where applicable), and custom validation rules (predefined options).
*   **Large Files:**  Streaming processing, background processing, progress indicators, and resumable imports will be implemented for large files.

## Challenges and Considerations

*   **UI Complexity:** Designing a user-friendly interface for defining complex schemas remains a key challenge. We'll prioritize simplicity and usability, leveraging user testing and iterative design.
*   **Security:**  Strict input validation and the *prohibition of custom code input* are crucial for preventing security vulnerabilities.
*   **Scalability:**  The system will be designed for horizontal scalability, using load balancing, caching, and efficient database queries.
*   **Database Schema Management:**  While dynamic table creation is not supported initially, future considerations might involve exploring safe and controlled ways to manage schema evolution.
*   **Error Handling:**  Robust error handling and clear error reporting are essential for a positive user experience.
*   **Versioning:**  The versioning system must be robust and easy to understand, allowing for smooth transitions between endpoint versions.

## The Power of the API-Centric Approach

The FastAPI backend is the *core* of our platform. This API-centric design offers:

*   **Flexibility:** Direct API access for developers and data scientists.
*   **Integration:** Easy integration with other systems and tools.
*   **Scalability:** FastAPI's high performance and scalability.
*   **Automation:**  Automation of data import, annotation, and analysis tasks.
*   **Future-Proofing:**  A stable foundation for future development.

## Conclusion

By embracing dynamic endpoint generation, a schema-driven architecture, and a strong focus on security and usability, we will transform our current annotation backend into a powerful, flexible, and universal platform. This will empower users to manage and annotate diverse data types, create custom APIs, and streamline their workflows without requiring constant code modifications. The "beta" feature approach allows for iterative development and user feedback. The FastAPI backend remains the core, providing a robust and scalable foundation. We will prioritize a user-friendly Streamlit UI, comprehensive error handling, and robust security measures throughout the development process.